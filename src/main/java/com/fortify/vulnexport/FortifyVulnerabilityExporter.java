package com.fortify.vulnexport;

import java.io.File;
import java.io.IOException;
import java.nio.file.Files;
import java.nio.file.Path;
import java.nio.file.Paths;
import java.util.ArrayList;
import java.util.Arrays;
import java.util.List;
import java.util.Objects;
import java.util.stream.Stream;

import javax.annotation.PostConstruct;

import org.apache.commons.lang.StringUtils;
import org.springframework.boot.autoconfigure.SpringBootApplication;
import org.springframework.boot.builder.SpringApplicationBuilder;
import org.springframework.boot.logging.DeferredLog;
import org.springframework.boot.system.ApplicationHome;
import org.springframework.context.ApplicationEvent;
import org.springframework.context.ApplicationListener;

import com.fortify.util.spring.boot.container.PopulateContainerDirs;
import com.fortify.util.spring.boot.scheduler.RunOrSchedule;
import com.fortify.util.spring.environment.FortifyEnvironment;
import com.fortify.util.spring.expression.helper.DefaultExpressionHelper;
import com.fortify.vulnexport.api.vuln.loader.IVulnerabilityLoaderFactory;

/**
 * This class contains the {@link #main(String[])} method for starting FortifyVulnerabilityExporter.
 * It utilizes Spring Boot functionality together with functionality provided by the {@link RunOrSchedule}
 * class to start the application. Based on the configuration provided by {@link FortifyVulnerabilityExporterRunnerConfig}
 * and the optional <code>runOnce</code> property, the {@link FortifyVulnerabilityExporterRunnerFactory#runActiveVulnerabilityLoader()} 
 * method will be invoked either once (exiting afterwards), or on a scheduled basis. This method in turn will load
 * all available {@link IVulnerabilityLoaderFactory} instances, and invoke the active factory/factories to actually
 * start loading vulnerabilities and exporting these to the target systems.
 * 
 * @author Ruud Senden
 *
 */
@SpringBootApplication(scanBasePackages= {"com.fortify.vulnexport", "com.fortify.util"})
public class FortifyVulnerabilityExporter implements ApplicationListener<ApplicationEvent> {
	private static final String[] CONFIG_FILE_EXTENSIONS = new String[] { "yml", "yaml", "properties" };
	private static final DeferredLog log = new DeferredLog();
	
	@Override
	public void onApplicationEvent(ApplicationEvent event) {
		log.replayTo(FortifyVulnerabilityExporter.class);
	}
	
	
	
	/**
	 * Start the application
	 * @param args Application arguments
	 * @throws IOException If there is any error while populating container directories
	 */
	public static void main(String[] args) throws IOException {
		disableNashornDeprecationWarning();
		PopulateContainerDirs.populateContainerDirs();
		DefaultExpressionHelper.set(FortifyVulnerabilityExporterExpressionHelper.get());
		new SpringApplicationBuilder(FortifyVulnerabilityExporter.class)
			.environment(new FortifyEnvironment())
			.build().run(updateArgs(args));
	}

	private static final void disableNashornDeprecationWarning() {
		try {
			double version = Double.parseDouble(System.getProperty("java.specification.version"));
			if ( version>=11 ) {
				// Disable Nashorn deprecation warning if on java >= 11
				System.setProperty("nashorn.args", "--no-deprecation-warning");
			}
		} catch ( RuntimeException ignore ) {}
	}
	
	/**
	 * Update the given args[] is necessary
	 * @param args array to be updated
	 * @return updated args array
	 */
	private static final String[] updateArgs(String[] args) {
		ArrayList<String> argsList = new ArrayList<>(Arrays.asList(args));
		updateArgsWithConfigFile(argsList);
		return argsList.toArray(new String[argsList.size()]);
	}

	/**
	 * If the first argument doesn't start with a '-', we consider it
	 * to be a configuration file identifier. In that case, we try to
	 * find the appropriate configuration file and then update the
	 * first argument accordingly.
	 * @param argsList to be checked and updated for configuration file
	 */
	private static final void updateArgsWithConfigFile(ArrayList<String> argsList) {
		if ( argsList.size()>0 ) {
			String firstArg = argsList.get(0);
			if ( !firstArg.startsWith("-") ) {
				String configFile = getConfigFile(firstArg);
				if ( StringUtils.isBlank(configFile) ) {
					log.warn("No configuration file found for "+firstArg);
				} else {
					log.info("Using configuration file "+configFile);
					argsList.set(0, "--export.config="+configFile);
				}
			}
		}
	}

	private static final String getConfigFile(String configFileSpec) {
		if ( new File(configFileSpec).isAbsolute() ) {
			return configFileSpec;
		} else {
			return determineConfigFilePath(configFileSpec);
		}
	}

	private static final String determineConfigFilePath(String configFileSpec) {
		List<Path> defaultConfigFileLocations = getDefaultConfigFileLocations();
		return defaultConfigFileLocations.stream()
			.map(dir->findConfigFile(dir, configFileSpec))
			.filter(Objects::nonNull).findFirst().orElse(null);
	}
	
	private static final String findConfigFile(Path path, String configFileSpec) {
		if ( StringUtils.endsWithAny(configFileSpec, CONFIG_FILE_EXTENSIONS) ) {
			return resolveConfigFile(path, configFileSpec);
		} else {
			return Stream.of(CONFIG_FILE_EXTENSIONS)
				.map(ext->resolveConfigFile(path, configFileSpec+"."+ext))
				.filter(Objects::nonNull).findFirst().orElse(null);
		}
	}
	
	private static final String resolveConfigFile(Path path, String configFile) {
		String result = null;
		Path configFilePath = path.resolve(configFile).toAbsolutePath().normalize();
		if ( Files.isReadable(configFilePath) ) {
			result = configFilePath.toString();
		} else if ( Files.exists(configFilePath) ) {
			throw new IllegalStateException("Found non-readable configuration file, please check permissions: "+configFilePath.toString());
		}
		return result;
	}
	
	private static final List<Path> getDefaultConfigFileLocations() {
		Path appDir = getAppDir();
		return Arrays.asList(
			Paths.get(".").toAbsolutePath().normalize(),
			Paths.get("./config").toAbsolutePath().normalize(),
			appDir.resolve("config"),
			appDir,
			Paths.get("/config")
		);
	}
	
	private static final Path getAppDir() {
		ApplicationHome appHome = new ApplicationHome(FortifyVulnerabilityExporter.class);
		return appHome.getDir().toPath().toAbsolutePath().normalize();
	}
}
