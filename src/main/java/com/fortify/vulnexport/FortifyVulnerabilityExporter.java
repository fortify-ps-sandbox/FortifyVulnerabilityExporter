package com.fortify.vulnexport;

import java.io.File;
import java.nio.file.Files;
import java.nio.file.Path;
import java.nio.file.Paths;
import java.util.ArrayList;
import java.util.Arrays;
import java.util.List;
import java.util.stream.Collectors;
import java.util.stream.Stream;

import org.apache.commons.lang.StringUtils;
import org.springframework.boot.autoconfigure.SpringBootApplication;
import org.springframework.boot.builder.SpringApplicationBuilder;
import org.springframework.boot.logging.DeferredLog;
import org.springframework.boot.system.ApplicationHome;
import org.springframework.context.ApplicationEvent;
import org.springframework.context.ApplicationListener;

import com.fortify.util.spring.boot.container.PopulateContainerDirs;
import com.fortify.util.spring.boot.scheduler.RunOrSchedule;
import com.fortify.util.spring.environment.FortifyEnvironment;
import com.fortify.util.spring.expression.helper.DefaultExpressionHelper;
import com.fortify.vulnexport.api.vuln.loader.IVulnerabilityLoaderFactory;

/**
 * This class contains the {@link #main(String[])} method for starting FortifyVulnerabilityExporter.
 * It utilizes Spring Boot functionality together with functionality provided by the {@link RunOrSchedule}
 * class to start the application. Based on the configuration provided by {@link FortifyVulnerabilityExporterRunnerConfig}
 * and the optional <code>runOnce</code> property, the {@link FortifyVulnerabilityExporterRunnerFactory#runActiveVulnerabilityLoader()} 
 * method will be invoked either once (exiting afterwards), or on a scheduled basis. This method in turn will load
 * all available {@link IVulnerabilityLoaderFactory} instances, and invoke the active factory/factories to actually
 * start loading vulnerabilities and exporting these to the target systems.
 * 
 * @author Ruud Senden
 *
 */
@SpringBootApplication(scanBasePackages= {"com.fortify.vulnexport", "com.fortify.util"})
public class FortifyVulnerabilityExporter implements ApplicationListener<ApplicationEvent> {
	private static final String[] CONFIG_FILE_EXTENSIONS = new String[] { "yml", "yaml", "properties" };
	private static final DeferredLog log = new DeferredLog();
	
	@Override
	public void onApplicationEvent(ApplicationEvent event) {
		log.replayTo(FortifyVulnerabilityExporter.class);
	}
	
	
	
	/**
	 * Start the application
	 * @param args Application arguments
	 */
	public static void main(String[] args) {
		try {
			disableNashornDeprecationWarning();
			PopulateContainerDirs.populateContainerDirs();
			DefaultExpressionHelper.set(FortifyVulnerabilityExporterExpressionHelper.get());
			new SpringApplicationBuilder(FortifyVulnerabilityExporter.class)
				.environment(new FortifyEnvironment())
				.build().run(updateArgs(args));
		} catch ( Exception e ) {
			// We catch and process any exceptions here, to avoid Spring Boot loader 
			// from wrapping any exceptions into an InvocationTargetException, making
			// it easier for users to see the actual error
			e.printStackTrace(System.err);
			System.exit(1);
		}
	}

	private static final void disableNashornDeprecationWarning() {
		try {
			double version = Double.parseDouble(System.getProperty("java.specification.version"));
			if ( version>=11 ) {
				// Disable Nashorn deprecation warning if on java >= 11
				System.setProperty("nashorn.args", "--no-deprecation-warning");
			}
		} catch ( RuntimeException ignore ) {}
	}
	
	/**
	 * Update the given args[] is necessary
	 * @param args array to be updated
	 * @return updated args array
	 */
	private static final String[] updateArgs(String[] args) {
		ArrayList<String> argsList = new ArrayList<>(Arrays.asList(args));
		updateArgsWithConfigFile(argsList);
		return argsList.toArray(new String[argsList.size()]);
	}

	/**
	 * If the first argument doesn't start with a '-', we consider it
	 * to be a configuration file identifier. In that case, we try to
	 * find the appropriate configuration file and then update the
	 * first argument accordingly.
	 * @param argsList to be checked and updated for configuration file
	 */
	private static final void updateArgsWithConfigFile(ArrayList<String> argsList) {
		if ( argsList.size()>0 ) {
			String firstArg = argsList.get(0);
			if ( !firstArg.startsWith("-") ) {
				String configFile = getConfigFilePath(firstArg).normalize().toString();
				log.info("Using configuration file "+configFile);
				argsList.set(0, "--export.config="+configFile);
			}
		}
	}

	private static final Path getConfigFilePath(String configFileSpec) {
		Path configFilePath;
		if ( new File(configFileSpec).isAbsolute() ) {
			configFilePath = Paths.get(configFileSpec);
		} else {
			configFilePath = findConfigFilePath(configFileSpec);
		}
		checkConfigFilePath(configFileSpec, configFilePath);
		return configFilePath;
	}

	private static final void checkConfigFilePath(String configFileSpec, Path configFilePath) {
		if ( configFilePath==null ) {
			throw new IllegalArgumentException("No configuration file found for "+configFileSpec);
		} else if ( !Files.exists(configFilePath) ) {
			throw new IllegalStateException("Configuration file does not exist: "+configFilePath.toString());
		} else if ( !Files.isReadable(configFilePath) ) {
			throw new IllegalStateException("Found non-readable configuration file, please check permissions: "+configFilePath.toString());
		}
	}

	private static final Path findConfigFilePath(final String configFileSpec) {
		List<Path> defaultConfigFileLocations = getDefaultConfigFileLocations();
		List<String> configFileNames = getConfigFileNames(configFileSpec);
		return defaultConfigFileLocations.stream()
			.flatMap(dir->configFileNames.stream().map(f->dir.resolve(f)))
			.filter(Files::exists)
			.findFirst().orElse(null);
	}
	
	private static final List<String> getConfigFileNames(final String configFileSpec) {
		return StringUtils.endsWithAny(configFileSpec, CONFIG_FILE_EXTENSIONS)
				? Arrays.asList(configFileSpec)
				: Stream.of(CONFIG_FILE_EXTENSIONS).map(ext->configFileSpec+"."+ext).collect(Collectors.toList());
	}
	
	private static final List<Path> getDefaultConfigFileLocations() {
		Path jarDir = getJarDir();
		return Arrays.asList(
			Paths.get(".").toAbsolutePath(),
			Paths.get("./config").toAbsolutePath(),
			jarDir,
			jarDir.resolve("config"),
			Paths.get("/config")
		);
	}
	
	private static final Path getJarDir() {
		ApplicationHome appHome = new ApplicationHome(FortifyVulnerabilityExporter.class);
		return appHome.getDir().toPath().toAbsolutePath();
	}
}
