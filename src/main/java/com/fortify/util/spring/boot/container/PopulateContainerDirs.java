/*******************************************************************************
 * (c) Copyright 2020 Micro Focus or one of its affiliates
 *
 * Permission is hereby granted, free of charge, to any person obtaining a 
 * copy of this software and associated documentation files (the 
 * "Software"), to deal in the Software without restriction, including without 
 * limitation the rights to use, copy, modify, merge, publish, distribute, 
 * sublicense, and/or sell copies of the Software, and to permit persons to 
 * whom the Software is furnished to do so, subject to the following 
 * conditions:
 * 
 * The above copyright notice and this permission notice shall be included 
 * in all copies or substantial portions of the Software.
 * 
 * THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY 
 * KIND, EXPRESS OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE 
 * WARRANTIES OF MERCHANTABILITY, FITNESS FOR A PARTICULAR 
 * PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE 
 * AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, 
 * DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION OF 
 * CONTRACT, TORT OR OTHERWISE, ARISING FROM, OUT OF OR IN 
 * CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS 
 * IN THE SOFTWARE.
 ******************************************************************************/
package com.fortify.util.spring.boot.container;

import java.io.IOException;
import java.nio.file.CopyOption;
import java.nio.file.FileVisitResult;
import java.nio.file.Files;
import java.nio.file.Path;
import java.nio.file.Paths;
import java.nio.file.SimpleFileVisitor;
import java.nio.file.attribute.BasicFileAttributes;

import org.slf4j.Logger;
import org.slf4j.LoggerFactory;

/**
 * <p>When mounting an empty volume into a container directory, Docker will populate the volume using any files
 * that exist in that container directory. However, when using bind mounts (or when mounting a non-empty volume),
 * the mount will hide the original container contents. See https://docs.docker.com/storage/#tips-for-using-bind-mounts-or-volumes
 * for details.</p> 
 * 
 * <p>This class allows for consistent user experience independent of whether container directories are not mounted, 
 * mounted as a volume, or mounted using a bind mount, by recursively copying files from a container source directory
 * to a possibly mounted target directory. This somewhat mimics the Docker behavior when using empty volume mounts,
 * with the following characteristics:</p>
 * <ul>
 *  <li>The source directory is configured using the <code>populateContainerDirs.sourceDir</code> system property, 
 *      defaulting to <code>/default</code></li>
 *  <li>The target directory is configured using the <code>populateContainerDirs.targetDir</code> system property, 
 *      defaulting to the container root directory</li>
 *  <li>Copying only takes places if the <code>populateContainerDirs</code> system property is set to <code>true</code>
 *  <li>Each sub-directory in the source directory is only copied if that sub-directory does not yet exist in the
 *      target directory, or if it is empty in the target directory</li>
 * <ul>
 * 
 * <p>To enable this behavior, applications should call the {@link #populateContainerDirs()} method on application
 * start-up.</p>
 * 
 * @author Ruud Senden
 *
 */
public final class PopulateContainerDirs {
	private static final Logger LOG = LoggerFactory.getLogger(PopulateContainerDirs.class);
	
	/**
	 * Populate container directories (see class description for details)
	 * @throws IOException if there is any error while populating container directories  
	 */
	public static final void populateContainerDirs() throws IOException {
		boolean populateContainerDirsEnabled = "true".equals(System.getProperty("populateContainerDirs"));
		LOG.debug("Populate container directories enabled: {}", populateContainerDirsEnabled);
		if ( populateContainerDirsEnabled ) {
			LOG.debug("Checking whether container directories need to be initialized");
			Path sourcePath = Paths.get(System.getProperty("populateContainerDirs.sourceDir", "/default"));
			
			if ( Files.exists(sourcePath) ) {
				Files.list(sourcePath).forEach(PopulateContainerDirs::populate);
			}
		}
	}
	
	/**
	 * Populate a target file or directory from the given sourcePath if the target does not yet exist or is empty.  
	 */
	private static final void populate(Path sourcePath) {
		Path targetPath = Paths.get(System.getProperty("populateContainerDirs.targetDir", "/")).resolve(sourcePath.getFileName());
		try {
			if (isTargetNotPresentOrEmpty(targetPath)) {
				copy(sourcePath, targetPath);
			}
		} catch (IOException e) {
			throw new RuntimeException("Error copying files", e);
		}
	}

	/**
	 * @return true if the given targetPath does not exist or is empty (ignoring any files named .empty)
	 */
	private static boolean isTargetNotPresentOrEmpty(Path targetPath) throws IOException {
		boolean isPresent = Files.exists(targetPath) || 
				(Files.isDirectory(targetPath) && !Files.list(targetPath).anyMatch(PopulateContainerDirs::anyButEmpty));
		LOG.debug("Target path {} is present: {}", targetPath.toString(), isPresent);
		return !isPresent;
	}
	
	/**
	 * @return true for any file except a file named .empty
	 */
	private static final boolean anyButEmpty(Path p) {
		return !".empty".equals(p.getFileName().toString());		
	}
	
	/**
	 * Copy the given sourcePath to the given targetPath, where sourcePath may be either 
	 * a single file or a directory that will be recursively copied. 
	 */
	private static final void copy(Path sourcePath, Path targetPath) throws IOException {
		LOG.info("Copying {} to {}", sourcePath, targetPath);
		if ( Files.isDirectory(sourcePath) ) {
			copyFolder(sourcePath, targetPath);
		} else {
			Files.copy(sourcePath, targetPath);
		}
	}

	/**
	 * Recursively copy the folder identified by the given sourcePath to the given targetPath using the given copy options.
	 */
	private static final void copyFolder(Path sourcePath, Path targetPath, CopyOption... options) throws IOException {
        Files.walkFileTree(sourcePath, new SimpleFileVisitor<Path>() {

            @Override
            public FileVisitResult preVisitDirectory(Path dir, BasicFileAttributes attrs) throws IOException {
            	Path targetDirectory = targetPath.resolve(sourcePath.relativize(dir));
            	LOG.debug("Creating directory {}", targetDirectory);
				Files.createDirectories(targetDirectory);
                return FileVisitResult.CONTINUE;
            }

            @Override
            public FileVisitResult visitFile(Path sourceFilePath, BasicFileAttributes attrs) throws IOException {
                Path targetFilePath = targetPath.resolve(sourcePath.relativize(sourceFilePath));
                LOG.debug("Copying {} to {}", sourceFilePath, targetFilePath);
				Files.copy(sourceFilePath, targetFilePath, options);
                return FileVisitResult.CONTINUE;
            }
        });
    }

}
